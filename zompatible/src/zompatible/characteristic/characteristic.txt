===============
CHARACTERISTICS
===============

A characteristic is a physical and intrinsic descriptive element of a product.
A product should be fully described by the list of its characteristics.
For instance, a TV screen can be described by its size, its weight, its resolution, etc.
So we should have a characteristic object that materialize the resolution.
For a motherboard, we can also have a characteristic object that represent
the CPU socket. That say, the motherboard has a socket 975, this socket is a
female socket. A characteristic can also store characteristics to have hierarchic
characteristics : A possible characteristic for a laptop is to have a DVD burner.
The dvd burner can have characteristics itself (weight), or features (burning speed)
So a product can itself be a characteristic : the burner is at the same time a 
characteristic of the laptop, and a product made by an organization.
This could be made by letting a product implement ICharacteristic (?)

Warning: Characteristics are (are they?) different from features.
Features are a functionnal description, and are used to describe
the usage of the product, what works, what doesn't work,
what can be enabled or disabled, etc.

Accessing object characteristics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's create a dummy object, so we can put characteristics on this object.

    >>> class MyObject(object):
    ...     pass
    >>> myobj = MyObject()

We register the adapter from ICharacterizable to ICharacteristics
and the annotation adapter

    >>> from zompatible.characteristic.interfaces import ICharacteristics, ICharacterizable
    >>> from zompatible.characteristic.characteristic import Characteristics
    >>> from zope.component import provideAdapter
    >>> provideAdapter(Characteristics, provides=ICharacteristics)

    >>> from zope.annotation.attribute import AttributeAnnotations
    >>> from zope.annotation.interfaces import IAttributeAnnotatable, IAnnotations
    >>> provideAdapter(AttributeAnnotations, provides=IAnnotations)

This object is not yet characterizable, we cannot get its characteristics::

    >>> ICharacteristics(myobj)
    Traceback (most recent call last):
    ...
    TypeError: ('Could not adapt',
                <MyObject object at ...>,
                <InterfaceClass zompatible.characteristic.interfaces.ICharacteristics>)

Now we make our object characterizable, so we can get the (empty) list
of characteristics::

    >>> from zope.interface import alsoProvides
    >>> alsoProvides(myobj, ICharacterizable)
    >>> characteristics = ICharacteristics(myobj).characteristics
    >>> characteristics
    []

Characteristic object
~~~~~~~~~~~~~~~~~~~~~

A characteristic is an object. There are so many characteristics that we can't write an
implementation for each one. But there are different classes of characteristics:
 - Some characteristics have only a name, a description, and a true/false value,
       ex: "Removable/replaceable power unit" : yes/no
 - other characteristics have a name, a description, a numerical value and a unit:
       ex: "Line-out maximum output" : 34 dBV
 - other characteristics have a name, a tuple of numerical values and a single unit:
       ex: "Display resolution" : 1280x1024 pixels
 - or three values in a tuple and a single unit : dimension (LongxLargxHaut): 40x50x60 mm
 - or n values and n units : 
 - or even a list : Certification : [ TCO'03, ISO 13406-2, MPR III, CE, TÃœV GS, FCC-B, UL/C-UL, VCCI-B]
 - or a range : Horizontal scan range : 24 - 80 KHz
 - or a text string : Colour of product : White
 - or even a compound characteristic :  Power supply type  :  AC 100 - 240 V, 50/60 Hz

Let's try to implement a screen resolution and a physical interface::

    >>> from zompatible.characteristic.characteristic import Characteristic
    >>> reso = Characteristic(name="Resolution", unit=("px","px") value=(1600, 1200)
    >>> characteristics.append(reso)
    >>> phys = Characteristic(name="PhysicalInterface", unit="", value=""(gender='Male')
    >>> characteristics.append(phys)
    >>> phys.gender
    'Male'
    



We express the fact that the device can have physical interfaces by adding 
a marker interface::

    >>> from zope.interface import alsoProvides
    >>> from zompatible.characteristic.interfaces import IHasPhysicalInterfaces
    >>> alsoProvides(multi,IHasPhysicalInterfaces)

Having IHasPhysicalInterfaces means that we can lookup an IPhysicalInterfaces adapter to manage the physical interfaces::

    >>> from zompatible.characteristic.characteristic import PhysicalInterfaces
    >>> provideAdapter(PhysicalInterface)
    >>> physinterfaces = IPhysicalInterfaces(multi)
    >>> physinterfaces
    to fill: <class PhysicalInterfaces>
    >>> IPhysicalInterfaces.providedBy(physinterfaces)
    True

For now, the physical interfaces is an empty list of PhysicalInterface objects.

    >>> physinterfaces
    []

We can also list the characteristics, which is still an empty list::

    >>> ICharacteristics(multi)
    []

The device has two communication ports: usb2 and parallel
We create and add them to the list of phys interfaces::

    >>> usb2 = PhysicalInterface(name=u'USB', version="2.0")
    >>> parallel = PhysicalInterface(name=u'Parallel')
    >>> physinterfaces.append(usb2)
    >>> physinterfaces.append(parallel)
    >>> physinterfaces
    to fill: [<class PhysicalInterface>, <class PhysicalInterface>]

A PhysicalInterface object must at least have a name::

    >>> invalid = PhysicalInterface()
    to fill: ERROR bidule

We can be more precise to define a physical interface, say we have a bluetooth connection on the device.

    >>> from zompatible.characteristic.characteristic import WirelessInterface
    >>> IPhysicalInterface.implementedBy(WirelessInterface)
    True
    >>> bluetooth = WirelessInterface(name=u"Bluetooth", version="1.0")
    >>> physinterfaces.append(bluetooth)

We can also be more precise for the wired interfaces::

    >>> from zompatible.characteristic.characteristic import WiredInterface
    >>> physinterfaces.remove(usb2)
    >>> usb2 = WiredInterface(name=u'USB', version="2.0")
    >>> IPhysicalInterface.providedBy(usb2)
    True
    >>> physinterfaces.append(usb2)

After having added these two communication ports, they appear as characteristics::

    >>> ICharacteristics(multi)
    to fill: [<class PhysicalInterface>, <class WirelessInterface>, <class WiredInterface>]
    
Now we add the subproduct 'scanner' into the multifunction product.

First we create a scanner product with the resolution characteristic::

    >>> scanner = Product(name = u'Scanner')
    >>> from zompatible.characteristic.interfaces import IResolution, IHasResolution, IResolutions
    >>> from zompatible.characteristic.characteristic import Resolution, Resolutions
    >>> alsoProvides(scanner, IHasResolution)

We can get the resolutions provided by the scanner, as well as the best resolution

    >>> provideAdapter(Resolutions)
    >>> provideAdapter(Resolution) # FIXME, why not several kinds of resolution adapters: ScanResolution, PrintResolution, DisplayResolution?
    >>> resolutions = IResolutions(scanner)
    >>> ICharacteristics.providedBy(resolutions)
    True
    >>> resolutions.append(Resolution(x=200, y=200))
    >>> resolutions.append(Resolution(x=2400, y=4800, unit='dpi'))
    >>> resolutions
    [ <class Resolution>, <class Resolution> ]

So the scanner has several resolutions available, but we can get *the* resolution
of the scanner, ie the best resolution.

    >>> resolution = IResolution(scanner)
    >>> resolution
    <class Resolution>
    >>> resolution.x
    2400
    >>> ICharacteristic.providedBy(resolution)
    True
    >>> resolution.unit
    'dpi'

We can list the characteristics of the scanner::

    >>> ICharacteristics(scanner)
    to fill: [ <Resolution ...> ]

A product can have sub-products.
We consider this scanner is part of the multifunction device,
We add it as a sub-product::

    >>> len(multi)
    0
    >>> multi[scanner.name] = scanner
    >>> len(multi)
    1

Now the multifunction device has only the characteristics of itself,
but we can retrieve all the characteristics recursively
(retrieved as a list of Characteristic objects),
as well as the characteristics of the scanner, as a single Characteristic*s* object.

    >>> characteristics = ICharacteristics(multi)
    >>> characteristics
    to fill: [<class PhysicalInterface>, <class WirelessInterface>, <class WiredInterface>]
    >>> characteristics.get_recurse()
    to fill: [<class PhysicalInterface>, <class WirelessInterface>, <class WiredInterface>, <class Characteristics>]

We can know where the latter Characteristics object comes from::

    >>> characteristics.get_recurse()[3].context.name
    Scanner

Or list the characteristics of the scanner::

    >>> list(characteristics.get_recurse()[3])
    to fill: [ <Resolution ...> ]

Our multifunction device also has a flashcard reader
...


============
 COMPARISON
============
We check that the comparison between the printer and the scanner resolution works:
    >>> IResolution(multi.get_product(u'Printer')) < IResolution(scanner)
    False
    >>> IResolution(scanner).x = 9600
    >>> IResolution(multi.get_product(u'Printer')) < IResolution(scanner)
    True

