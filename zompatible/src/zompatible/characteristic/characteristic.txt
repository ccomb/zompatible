
===============
CHARACTERISTICS
===============

Every product has characteristics, so we always have an ICharacteristics adapter on any product.
Our device has no characteristics yet (empty list)::

    >>> from zompatible.characteristic.characteristic import Characteristics
    >>> from zope.component import provideAdapter
    >>> provideAdapter(Characteristics)
    >>> ICharacteristics(multi)
    []

We express the fact that the device can have physical interfaces by adding a marker interface::

    >>> from zope.interface import alsoProvides
    >>> from zompatible.characteristic.interfaces import IHasPhysInterfaces
    >>> alsoProvides(multi,IHasPhysInterfaces)

Having IHasPhysInterfaces means that we can lookup an IPhysInterfaces adapter to manage the physical interfaces::

    >>> from zompatible.characteristic.characteristic import PhysInterfaces
    >>> provideAdapter(PhysInterface)
    >>> physinterfaces = IPhysInterfaces(multi)
    >>> physinterfaces
    to fill: <class PhysInterfaces>
    >>> IPhysInterfaces.providedBy(physinterfaces)
    True

For now, the physical interfaces is an empty list of PhysInterface objects.

    >>> physinterfaces
    []

We can also list the characteristics, which is still an empty list::

    >>> ICharacteristics(multi)
    []

The device has two communication ports: usb2 and parallel
We create and add them to the list of phys interfaces::

    >>> usb2 = PhysInterface(name=u'USB', version="2.0")
    >>> parallel = PhysInterface(name=u'Parallel')
    >>> physinterfaces.append(usb2)
    >>> physinterfaces.append(parallel)
    >>> physinterfaces
    to fill: [<class PhysInterface>, <class PhysInterface>]

A PhysInterface object must at least have a name::

    >>> invalid = PhysInterface()
    to fill: ERROR bidule

We can be more precise to define a physical interface, say we have a bluetooth connection on the device.

    >>> from zompatible.characteristic.characteristic import WirelessInterface
    >>> IPhysInterface.implementedBy(WirelessInterface)
    True
    >>> bluetooth = WirelessInterface(name=u"Bluetooth", version="1.0")
    >>> physinterfaces.append(bluetooth)

We can also be more precise for the wired interfaces::

    >>> from zompatible.characteristic.characteristic import WiredInterface
    >>> physinterfaces.remove(usb2)
    >>> usb2 = WiredInterface(name=u'USB', version="2.0")
    >>> IPhysInterface.providedBy(usb2)
    True
    >>> physinterfaces.append(usb2)

After having added these two communication ports, they appear as characteristics::

    >>> ICharacteristics(multi)
    to fill: [<class PhysInterface>, <class WirelessInterface>, <class WiredInterface>]
    
Now we add the subproduct 'scanner' into the multifunction product.

First we create a scanner product with the resolution characteristic::

    >>> scanner = Product(name = u'Scanner')
    >>> from zompatible.characteristic.interfaces import IResolution, IHasResolution, IResolutions
    >>> from zompatible.characteristic.characteristic import Resolution, Resolutions
    >>> alsoProvides(scanner, IHasResolution)

We can get the resolutions provided by the scanner, as well as the best resolution

    >>> provideAdapter(Resolutions)
    >>> provideAdapter(Resolution) # FIXME, why not several kinds of resolution adapters: ScanResolution, PrintResolution, DisplayResolution?
    >>> resolutions = IResolutions(scanner)
    >>> ICharacteristics.providedBy(resolutions)
    True
    >>> resolutions.append(Resolution(x=200, y=200))
    >>> resolutions.append(Resolution(x=2400, y=4800, unit='dpi'))
    >>> resolutions
    [ <class Resolution>, <class Resolution> ]

So the scanner has several resolutions available, but we can get *the* resolution
of the scanner, ie the best resolution.

    >>> resolution = IResolution(scanner)
    >>> resolution
    <class Resolution>
    >>> resolution.x
    2400
    >>> ICharacteristic.providedBy(resolution)
    True
    >>> resolution.unit
    'dpi'

We can list the characteristics of the scanner::

    >>> ICharacteristics(scanner)
    to fill: [ <Resolution ...> ]

A product can have sub-products.
We consider this scanner is part of the multifunction device,
We add it as a sub-product::

    >>> len(multi)
    0
    >>> multi[scanner.name] = scanner
    >>> len(multi)
    1

Now the multifunction device has only the characteristics of itself,
but we can retrieve all the characteristics recursively
(retrieved as a list of Characteristic objects),
as well as the characteristics of the scanner, as a single Characteristic*s* object.

    >>> characteristics = ICharacteristics(multi)
    >>> characteristics
    to fill: [<class PhysInterface>, <class WirelessInterface>, <class WiredInterface>]
    >>> characteristics.get_recurse()
    to fill: [<class PhysInterface>, <class WirelessInterface>, <class WiredInterface>, <class Characteristics>]

We can know where the latter Characteristics object comes from::

    >>> characteristics.get_recurse()[3].context.name
    Scanner

Or list the characteristics of the scanner::

    >>> list(characteristics.get_recurse()[3])
    to fill: [ <Resolution ...> ]

Our multifunction device also has a flashcard reader
...


============
 COMPARISON
============
We check that the comparison between the printer and the scanner resolution works:
    >>> IResolution(multi.get_product(u'Printer')) < IResolution(scanner)
    False
    >>> IResolution(scanner).x = 9600
    >>> IResolution(multi.get_product(u'Printer')) < IResolution(scanner)
    True

