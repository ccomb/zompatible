
The component-specific tests below must all be moved into their own package
This test should rather be an integration test, that tries to use components simultaneously.
=======
PRODUCT
=======
A product can be hardware or software.

We define a new product (multi function USB printer/scanner/card reader)::

    >>> from zompatible.product.product import Product
    >>> from zope.interface import providedBy, alsoProvides
    >>> multi = Product(u'Hewlett-Packard PhotoSmart C5180')

A basic product is a contained persistent object, and is a container::

    >>> list(providedBy(multi))
    [<InterfaceClass zompatible.product.interfaces.IProduct>, <InterfaceClass zope.app.container.interfaces.IContainer>, <InterfaceClass zope.app.container.interfaces.IContained>, <InterfaceClass persistent.interfaces.IPersistent>]

Every product has characteristics, so we always have an ICharacteristics adapter on any product.
Our device has no characteristics yet (empty list)::

    >>> from zompatible.characteristic.characteristic import Characteristics
    >>> from zope.component import provideAdapter
    >>> provideAdapter(Characteristics)
    >>> ICharacteristics(multi)
    []

We express the fact that the device can have physical interfaces by adding a marker interface::

    >>> from zope.interface import alsoProvides
    >>> from zompatible.characteristic.interfaces import IHasPhysInterfaces
    >>> alsoProvides(multi,IHasPhysInterfaces)

Having IHasPhysInterfaces means that we can lookup an IPhysInterfaces adapter to manage the physical interfaces::

    >>> from zompatible.characteristic.characteristic import PhysInterfaces
    >>> provideAdapter(PhysInterface)
    >>> physinterfaces = IPhysInterfaces(multi)
    >>> physinterfaces
    to fill: <class PhysInterfaces>
    >>> IPhysInterfaces.providedBy(physinterfaces)
    True

For now, the physical interfaces is an empty list of PhysInterface objects.

    >>> physinterfaces
    []

We can also list the characteristics, which is still an empty list::

    >>> ICharacteristics(multi)
    []

The device has two communication ports: usb2 and parallel
We create and add them to the list of phys interfaces::

    >>> usb2 = PhysInterface(name=u'USB', version="2.0")
    >>> parallel = PhysInterface(name=u'Parallel')
    >>> physinterfaces.append(usb2)
    >>> physinterfaces.append(parallel)
    >>> physinterfaces
    to fill: [<class PhysInterface>, <class PhysInterface>]

A PhysInterface object must at least have a name::

    >>> invalid = PhysInterface()
    to fill: ERROR bidule

We can be more precise to define a physical interface, say we have a bluetooth connection on the device.

    >>> from zompatible.characteristic.characteristic import WirelessInterface
    >>> IPhysInterface.implementedBy(WirelessInterface)
    True
    >>> bluetooth = WirelessInterface(name=u"Bluetooth", version="1.0")
    >>> physinterfaces.append(bluetooth)

We can also be more precise for the wired interfaces::

    >>> from zompatible.characteristic.characteristic import WiredInterface
    >>> physinterfaces.remove(usb2)
    >>> usb2 = WiredInterface(name=u'USB', version="2.0")
    >>> IPhysInterface.providedBy(usb2)
    True
    >>> physinterfaces.append(usb2)

After having added these two communication ports, they appear as characteristics::

    >>> ICharacteristics(multi)
    to fill: [<class PhysInterface>, <class WirelessInterface>, <class WiredInterface>]
    
Now we add the subproduct 'scanner' into the multifunction product.

First we create a scanner product with the resolution characteristic::

    >>> scanner = Product(name = u'Scanner')
    >>> from zompatible.characteristic.interfaces import IResolution, IHasResolution
    >>> from zompatible.characteristic.characteristic import Resolution
    >>> alsoProvides(scanner, IHasResolution)
    >>> provideAdapter(Resolution) # FIXME, why not several kinds of resolution adapters: ScanResolution, PrintResolution, DisplayResolution?
    >>> resolution = IResolution(scanner)
    >>> ICharacteristic.providedBy(resolution)
    True
    >>> resolution.x = 2400
    >>> resolution.y = 4800
    >>> resolution.unit = 'dpi'

We can list the characteristics of the scanner::

    >>> ICharacteristics(scanner)
    to fill: [ <Resolution ...> ]

A product can have sub-products.
We consider this scanner is part of the multifunction device,
We add it as a sub-product::

    >>> len(multi)
    0
    >>> multi[scanner.name] = scanner
    >>> len(multi)
    1

Now the multifunction device has both the characteristics of itself,
(retrieved as a list of Characteristic objects),
as well as the characteristics of the scanner, as a single Characteristic*s* object.

    >>> characteristics = ICharacteristics(multi)
    >>> characteristics
    to fill: [<class PhysInterface>, <class WirelessInterface>, <class WiredInterface>, <class Characteristics>]

We can know where the latter Characteristics object comes from::

    >>> characteristics[3].context.name
    Scanner

Or list the characteristics of the scanner::

    >>> characteristics[3]
    to fill: [ <Resolution ...> ]


================
PRODUCT TEMPLATE (was categorynew)
================
A product template is a virtual product, with all the needed characteristic interfaces,
 with default values, and a set of default categories.
A product created from the template will get the same characteristics and categories.

    >>> from zompatible.product.template import ProductTemplate
    >>> printer_template = ProductTemplate(u'Printer')
    >>> alsoProvides(printer_template, IHasResolution)
    >>> IResolution(printer_template).name
    u'Resolution'
    >>> IResolution(printer_template).unit = 'dpi'
    >>> from zompatible.categorynew.interfaces import IIsPrinter
    >>> alsoProvides(printer_template, IIsPrinter)
    
The template can act as a product factory to create new products::

    >>> printer = printer_template.createProduct()
    to fill: ERROR missing name

Oops, we forgot the name::

    >>> printer = printer_template.createProduct(name=u'integrated printer')

We already can retrieve the general characteristics, or some specific characteristics.
They are normally empty::

    >>> ICharacteristics(printer)
    to fill: [ default characteristics common to all printers ]
    >>> IResolution(printer)
    to fill: [<class Resolution>]
    >>> IResolution(printer).unit
    None
    >>> IPhysInterface(printer)
    to fill: [<class PhysInterface>]

We set the correct resolution (wrong ones)::

    >>> IResolution(printer).x = 123
    >>> IResolution(printer).y = 'invalid'
    to fill: ERROR y resolution must be numeric
    >>> IResolution(printer).y = 456
    >>> IResolution(printer).unit = 'toto'
    to fill: ERROR bad unit (not in some dictionary) FIXME: how to support i18n? dpi = ppp (point par pouce)... i18n dependent dictionary? unit object?
    >>> IResolution(printer).unit = 'dpi'
    >>> IResolution(printer).x
    123
    >>> IResolution(printer).y
    456
    >>> printer.Display()
    Name: Printer
    Characteristics:
    Resolution: 123x456 dpi

We add the printer to the multifunction device

    >>> multi[printer.name] = printer

We can list the characteristics of the whole device.
It is sorted by every sub-product::

    >>> ICharacteristics(multi)
    to fill: [<class PhysInterface>, <class WirelessInterface>, <class WiredInterface>, <class Characteristics>]
    
==========
CATEGORIES
==========

Since our object has been created from a template, it is already categorizable::

    >>> from zompatible.category.interfaces import ICategorizable, ICategories
    >>> ICategorizable.providedBy(printer)
    True
    
So we can lookup an ICategories adapter, and retrieve the categories covered by the product::

    >>> categories = ICategories(printer)
    >>> categories
    tofill: <class Categories> ]
    >>> [ c.name for c in categories ]
    [ u'Printer' ]

Retrieve the sub product given its category type::

    >>> printer = multi.GetProduct(c[0])
    >>> printer.Display()
    Name: Printer
    Characteristics:
    Resolution: 123x456 dpi

Setting up the caracteristic of the printer (good ones)::

    >>> IResolution(printer).x = 4800
    >>> IResolution(printer).y = 4800
    >>> IResolution(printer).Display()
    Resolution: 4800x4800 dpi
    >>> multi.Display()    
    Name: Hewlett-Packard PhotoSmart C5180
    Characteristics:
    Interface: USB
    -----
    Name: Printer
    Characteristics:
    Resolution: 4800x4800 dpi
    -----
    Name: Scanner
    Characteristics:
    Resolution: 2400x4800 dpi
    
Adding a new category to the product:
    >>> from zompatible.characteristic.interfaces import IFlashCardSlots, IHasFlashCardSlots
    >>> from zompatible.categorynew.interfaces import IIsFlashCardReader
    >>> from zompatible.characteristic.characteristic import HasFlashCardSlots
        
    >>> cardReaderCategory = Category(u'Card Reader')
    >>> alsoProvides(cardReaderCategory, IIsFlashCardReader)
    >>> alsoProvides(cardReaderCategory, IHasFlashCardSlots)
    >>> provideAdapter(HasFlashCardSlots)
    
    >>> cf = cardReaderCategory.NewProduct()
    >>> IFlashCardSlots(cf).type = [ u'CF', u'SD' ]
    >>> multi[cf.name] = cf
    >>> multi.GetCategories()
    [u'Card Reader', u'Printer']
    
    >>> multi.Display()
    Name: Hewlett-Packard PhotoSmart C5180
    Characteristics:
    Interface: USB
    -----
    Name: Card Reader
    Characteristics:
    Flash card slots: CF,SD,
    -----
    Name: Printer
    Characteristics:
    Resolution: 4800x4800 dpi
    -----
    Name: Scanner
    Characteristics:
    Resolution: 2400x4800 dpi

============
 COMPARISON
============
We check that the comparison between the printer and the scanner resolution works:
    >>> IResolution(multi.GetProduct(u'Printer')) < IResolution(scanner)
    False
    >>> IResolution(scanner).x = 9600
    >>> IResolution(multi.GetProduct(u'Printer')) < IResolution(scanner)
    True

=========
 INDEXES
=========
In order to index products, they have to be stored in the ZODB. So we create a dummy database (cf p367 WCDZ3):
    >>> from ZODB.DemoStorage import DemoStorage
    >>> from ZODB import DB
    >>> db = DB(DemoStorage())
    >>> conn = db.open()
    >>> root = conn.root()
    >>> root['multifunction'] = multi
    >>> import transaction
    >>> transaction.commit()
    
    >>> from zope.app.keyreference.persistent import KeyReferenceToPersistent
    >>> from persistent.interfaces import IPersistent
    >>> provideAdapter(KeyReferenceToPersistent, adapts=[IPersistent])
    
    >>> from zope.app.intid import IntIds
    >>> from zope.app.intid.interfaces import IIntIds
    >>> from zope.component import provideUtility
    >>> intids = IntIds()
    >>> provideUtility(intids, IIntIds)
    >>> imulti = intids.register(multi)
    
Now, we can create the catalog and index the products:
    >>> from zope.app.catalog.catalog import Catalog
    >>> from zope.app.catalog.text import TextIndex
    >>> from zope.app.catalog.field import FieldIndex
    >>> from zope.app.catalog.attribute import AttributeIndex
    >>> from zope.app.catalog.interfaces import ICatalog
    >>> from zope.component import queryUtility
    
    >>> cat = Catalog()
    >>> provideUtility(cat, ICatalog, '')
    
    >>> cat2 = queryUtility(ICatalog)
    >>> cat2['interface'] = TextIndex(interface=IPhysInterface, field_name='interface', field_callable=False)
    >>> cat2.index_doc(intids.getId(multi), multi)
    
    >>> for result  in cat2.searchResults(interface=u'PCI'):
    ...        print result.name
    
Expecting nothing.

    >>> for result  in cat2.searchResults(interface=u'USB'):
    ...        print result.name
    Hewlett-Packard PhotoSmart C5180

    >>> from zope.component import getAllUtilitiesRegisteredFor
    >>> from zompatible.characteristic.interfaces import ICharacteristic

    >>> list(getAllUtilitiesRegisteredFor(IPhysInterface))
    >>> filter = ProductFilter()
    >>> alsoProvides(filter, IHasPhysInterfaces)
    >>> IPhysInterface(filter) = u'USB'
    >>> filter.Query()
    
    
    
    
===    
END
===    
    >>> from zompatible.organization.organization import Organization
    >>> from zope.interface import providedBy, alsoProvides, directlyProvidedBy, directlyProvides

We define a new organization
    >>> nvidia = Organization()
    >>> nvidia.names
    []
    >>> nvidia.names.append(u'Nvidia')
    >>> list(providedBy(nvidia))
    [<InterfaceClass zompatible.organization.interfaces.IOrganization>,
     <InterfaceClass zope.app.folder.interfaces.IFolder>,
     <InterfaceClass persistent.interfaces.IPersistent>,
     <InterfaceClass zope.app.component.interfaces.IPossibleSite>,
     <InterfaceClass zope.app.container.interfaces.IContained>]

    
    >>> usb = Caracteristic()
    >>> usb.name = 'USB'






Now we tell that a product is categorizable

    >>> alsoProvides(nvs, ICategorizable)
    >>> provideAdapter(ProductCategories) # implement(ICategories) adapts(ICategorizable)
    >>> categories = ICategories(nvs)
    
Category creation (Scanner)

    >>> from zompatible.categorynew.categorynew import Category
       >>> scanner = Category()
       >>> scanner.name = u'Scanner'
       
Adapter from ICaracterizable to ICaracteristics
    >>> from zompatible.caracteristic.caracteristic import Caracteristics
    >>> provideAdapter(Caracteristics)
    
Add all possible caracteristics to the category
    >>> alsoProvides(scanner, ICaracterizable)
    >>> ICaracteristics(Scanner).caracteristics
    []
    
Caracteristic creation
    >>> from zompatible.caracteristic.caracteristic import Caracteristic
    >>> usb = Caracteristic()
    >>> usb.name = 'USB'
    
To be able to add a caracteristic recursively we could provide ICaracterizable
    >>> # alsoProvides(usb, ICaracterizable)
    >>> usb2 = Caracteristic()
    >>> usb2.name = 'USB'


    >>> IPhysicalInterfaces(scanner) # means we have an adapter from IHasPhysicalInterface to IPhysicalInterface
    
    IPhysicalInterfaces de type ICaracteristic (type d'interface) ??
    
    >>> ICaracteristics(scanner)
    
We tell that usb is a physical interface

    >>> alsoProvides(usb, IPhysicalInterface)


    
Add a caracteristic to a category
    >>> 
    
Select a category for a product

Add a caracteristic to a product that is not included in a category

    
    




