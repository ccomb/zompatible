
The component-specific tests must all be moved into their own package
This test should rather be an integration test, that tries to use components simultaneously.










=========
 INDEXES
=========
In order to index products, they have to be stored in the ZODB. So we create a dummy database (cf p367 WCDZ3):
    >>> from ZODB.DemoStorage import DemoStorage
    >>> from ZODB import DB
    >>> db = DB(DemoStorage())
    >>> conn = db.open()
    >>> root = conn.root()
    >>> root['multifunction'] = multi
    >>> import transaction
    >>> transaction.commit()
    
    >>> from zope.app.keyreference.persistent import KeyReferenceToPersistent
    >>> from persistent.interfaces import IPersistent
    >>> provideAdapter(KeyReferenceToPersistent, adapts=[IPersistent])
    
    >>> from zope.app.intid import IntIds
    >>> from zope.app.intid.interfaces import IIntIds
    >>> from zope.component import provideUtility
    >>> intids = IntIds()
    >>> provideUtility(intids, IIntIds)
    >>> imulti = intids.register(multi)
    
Now, we can create the catalog and index the products:
    >>> from zope.app.catalog.catalog import Catalog
    >>> from zope.app.catalog.text import TextIndex
    >>> from zope.app.catalog.field import FieldIndex
    >>> from zope.app.catalog.attribute import AttributeIndex
    >>> from zope.app.catalog.interfaces import ICatalog
    >>> from zope.component import queryUtility
    
    >>> cat = Catalog()
    >>> provideUtility(cat, ICatalog, '')
    
    >>> cat2 = queryUtility(ICatalog)
    >>> cat2['interface'] = TextIndex(interface=IPhysInterface, field_name='interface', field_callable=False)
    >>> cat2.index_doc(intids.getId(multi), multi)
    
    >>> for result  in cat2.searchResults(interface=u'PCI'):
    ...        print result.name
    
Expecting nothing.

    >>> for result  in cat2.searchResults(interface=u'USB'):
    ...        print result.name
    Hewlett-Packard PhotoSmart C5180

    >>> from zope.component import getAllUtilitiesRegisteredFor
    >>> from zompatible.characteristic.interfaces import ICharacteristic

    >>> list(getAllUtilitiesRegisteredFor(IPhysInterface))
    >>> filter = ProductFilter()
    >>> alsoProvides(filter, IHasPhysInterfaces)
    >>> IPhysInterface(filter) = u'USB'
    >>> filter.Query()
    
    
    
    
===    
END
===    
    




Now we tell that a product is categorizable

    >>> alsoProvides(nvs, ICategorizable)
    >>> provideAdapter(ProductCategories) # implement(ICategories) adapts(ICategorizable)
    >>> categories = ICategories(nvs)
    
Category creation (Scanner)

    >>> from zompatible.categorynew.categorynew import Category
       >>> scanner = Category()
       >>> scanner.name = u'Scanner'
       
Adapter from ICaracterizable to ICaracteristics
    >>> from zompatible.caracteristic.caracteristic import Caracteristics
    >>> provideAdapter(Caracteristics)
    
Add all possible caracteristics to the category
    >>> alsoProvides(scanner, ICaracterizable)
    >>> ICaracteristics(Scanner).caracteristics
    []
    
Caracteristic creation
    >>> from zompatible.caracteristic.caracteristic import Caracteristic
    >>> usb = Caracteristic()
    >>> usb.name = 'USB'
    
To be able to add a caracteristic recursively we could provide ICaracterizable
    >>> # alsoProvides(usb, ICaracterizable)
    >>> usb2 = Caracteristic()
    >>> usb2.name = 'USB'


    >>> IPhysicalInterfaces(scanner) # means we have an adapter from IHasPhysicalInterface to IPhysicalInterface
    
    IPhysicalInterfaces de type ICaracteristic (type d'interface) ??
    
    >>> ICaracteristics(scanner)
    
We tell that usb is a physical interface

    >>> alsoProvides(usb, IPhysicalInterface)


    
Add a caracteristic to a category
    >>> 
    
Select a category for a product

Add a caracteristic to a product that is not included in a category

    
    




